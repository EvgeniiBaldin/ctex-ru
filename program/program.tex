%  -*- coding: koi8-r -*-
\chapter{Начала программирования}
\label{cha:program} {\setlength{\epigraphwidth}{0.63\textwidth}
  \epigraph{Когда придумываешь что-то сам, высок шанс ничего не
    придумать. Но когда живёшь чужим умом, уж точно ничего не
    придумаешь. Никогда не делай того, что делают другие. Это на 100\%
    обрекает на неудачу.}{\emph{Герш Ицкович Будкер}}}


\LaTeX{} позволяет не просто набирать текст "--- он позволяет его
программировать, а следовательно, перекладывать часть своей работы на
компьютер. Привычка думать "--- одна из самых необычных особенностей
разумного человека. Она позволяет экономить силы и время.



\section{Определённые размеры и переменные дл\'{и}ны}
\label{sec:program:length}


\LaTeX{} поддерживает переменные типа <<длина>> для определения
расстояния. Например, ранее в главе <<Вставка графики>> на
стр.~\pageref{ex:textwidth} уже упоминалась команда \textcmd{textwidth}
"--- это переменная, хранящая значение длины, равной ширине текста.

Для создания переменной типа <<длина>> необходимо воспользоваться
командой \textcmd{newlength}. В качестве обязательного параметра
передаётся имя переменной. При~создании переменной ей по умолчанию
присваивается нулевая длина, так что следующим шагом необходимо
приравнять её чему-либо с помощью команды \textcmd{setlength}:
\medskip

\begin{examplenv}[0.62\textwidth]{length-def}
\newlength{\MyLength}
\setlength{\MyLength}{1cm plus 2.5fill minus 5mm}
\addtolength{\MyLength}{5em}
Длина \lstinline!\MyLength! равна \the\MyLength.
\end{examplenv}

Длина в \LaTeX{} не просто какой-то определённый размер "--- это
более сложная структура с указанием границ возможного сжатия и
растяжения. Границы растяжения определяются с помощью инструкции
plus, а сжатия "--- minus. При~формировании абзацев
\TeX{} использует эту информацию для максимально <<красивого>>
заполнения.

Команда \textcmd{setlength} эквивалентна оператору присваивания.  В
свою очередь команда \textcmd{addtolength} позволяет увеличить
переменную на указанную величину, которая может быть
отрицательной. Макрос \textcmd{the} позволяет <<развернуть>>
переменную длины для вывода на печать.

\LaTeX{} <<говорит>> в терминах англо-американской системы мер. Эта
система отживает своё, но её наследие будет ещё долго проявляться и
портить жизнь современному <<метрическому>> миру. Для определённости
следует знать, что один дюйм (in) равен 2.54 сантиметра и в нём
умещается 72.27 пунктов
(\(1\,\text{pt}\simeq0.35\,\text{mm}\)). Метрические величины
представлены привычными сантиметрами (cm) и миллиметрами (mm). Кроме
упомянутых \LaTeX{} умеет оперировать с размерами в~больших пунктах
(bp), пунктах Дидо (dd), пиках (pc) и цицеро (cc) "--- традиционные
единицы измерения, используемые в типографиях. Минимальной ненулевой
единицей длины в \LaTeX{} является приведённый пункт (sp), который
составляет 1/65536 от одного пункта.

Кроме определённых единиц измерения длины можно задавать также и в
относительных: 1ex соответствует высоте строчной латинской буквы x, а
1em "--- ширине прописной латинской буквы M. Эти величины меняются
вместе со сменой шрифта, что позволяет задавать автоматически
масштабирующиеся горизонтальные и вертикальные промежутки, не привязанные к
конкретному размеру и типу шрифта. Например, широкий пробел,
задаваемый с помощью команды \textcmd{quad}, определяется как
\lstinline!\hspace{1em}!.
\medskip

%precommand \newlength{\MyLength}
\begin{examplenv}[0.45\textwidth]{length-ex-and-em}
\setlength{\MyLength}{1ex}
Высота x равна \the\MyLength\par
\Large \setlength{\MyLength}{1ex}
Высота x равна \the\MyLength
\end{examplenv}
\medskip


Интересной инструкцией является длина fill "--- это
\emph{бесконечность}. \TeX{} поддерживает операции с бесконечностями,
причём оперирует тремя видами бесконечностей: fil, fill и filll, где
\(\text{fil}\ll\text{fill}\ll\text{filll}\). С помощью этих сущностей
производится центрирование боксов и более сложные выравнивания.

Если хочется узнать ширину  текста, то следует воспользоваться
командой \textcmd{settowidth}:
\medskip

%precommand \newlength{\MyLength}
\begin{examplenv}[0.62\textwidth]{settowidth}
\settowidth{\MyLength}{очень длинная фраза}
\addtolength{\MyLength}{1em}
\centering
\framebox[1.2\MyLength]{очень длинная фраза}\par
\framebox[1.2\MyLength]{короткая фраза}
\end{examplenv}
\medskip

Аналогично команда \textcmd{settoheight} позволяет выяснить высоту
текста над базовой линией, а \textcmd{settodepth} "--- глубину под
базовой линей. При использовании длины можно добавить перед ней
множитель.

А теперь немного <<магии>> из английского FAQ по \LaTeX:
\begin{lstlisting}
\makeatletter|\footnote{Комбинация команд \textcmd{makeatletter}/\textcmd{makeatother} нужна для того чтобы получить доступ к внутренней \LaTeX-команде. Такие  команды традиционно используют символ @ в своём названии,  что предотвращает случайное использование этих команд новичками.}|
\newcommand{\maxwidth}{%
 \ifdim\Gin@nat@width>\linewidth
    \linewidth
 \else
    \Gin@nat@width
 \fi
}
\makeatother

\end{lstlisting}
Эта конструкция определяет переменную длины \textcmd{maxwidth}
таким образом, что при вставке картинки:
\begin{lstlisting}[frame=]
\includegraphics[width=\maxwidth]{|<<картинка>>|}

\end{lstlisting}
ширина картинки становится равной минимальной из двух возможных
значений: <<естественной>> ширине картинки (размер в BoundingBox) или
ширине строки. Это позволяет вывести картинку в натуральную величину
при условии, что она не вылезает за рамки дозволенного, и <<запихать>> её в
эти рамки, коли она за~них вылезает.



\section{Счётчики}
\label{sec:prog:counters}


Для нумерации разделов, перечней, плавающих окружений, формул и
прочего используются счётчики (counter).  Как и в случае с длинами в
\LaTeX{} представлена и целочисленная арифметика с использованием
счётчиков в качестве переменных:
\medskip

\begin{examplenv}[0.6\textwidth]{count-def}
\newcounter{MyCount}
\setcounter{MyCount}{5}
Значение MyCount равно \arabic{MyCount}, 
или~\alph{MyCount}, или  \Asbuk{MyCount}.\par
\addtocounter{MyCount}{1550}
\arabic{MyCount} эквивалентно \Roman{MyCount}.
\end{examplenv}
\medskip

Новый счётчик создаётся с помощью команды \textcmd{newcounter} и
 инициализируется нулём. Создание счётчика
является глобальной операцией, то есть при компиляции информация о его
создании не исчезнет, даже если новый счётчик был определён внутри
окружения. Для присвоения счётчику другого значения используется
команда \textcmd{setnewcounter}, а для изменения на какое-то
определённое число "--- \textcmd{addtocounter}.

\mindex{русификация!счётчик}

В отличие от длин, основная роль которых помнить размеры какого-то
определённого бокса, счётчики используются для отображения какой-либо
структурной информации. Поэтому особое внимание уделяется оформлению
вывода счётчиков. Чтобы просто отобразить численное значение счётчика
с помощью арабских цифр, используется команда
\textcmd{arabic}\lstinline!{счётчик}!. Для римской числовой нотации
необходимо воспользоваться командой \textcmd{Roman} и \textcmd{roman}
"--- заглавные и строчные буквы соответственно. Счётчик может быть
представлен также буквой алфавита: \textcmd{alph} "--- латинская
строчная, \textcmd{asbuk} "--- кириллическая строчная и
\textcmd{Asbuk} "--- кириллическая заглавная.

В стандартных классах уже определён набор счётчиков, в которых хранятся
номера страницы (счётчик \textcount{page}), раздела (соответственно
счётчики \textcount{part}, \textcount{chapter}, \textcount{section},
\textcount{subsection}, \textcount{subsubsection} и т.\,д.),
подстрочного примечания (\textcount{footnote}), плавающих
окружений (счётчики \textcount{figure} и \textcount{table}) и формул
(\textcount{equation}). 

При создании счётчика также автоматически создаётся команда с
префиксом \textcmd{the} перед именем счётчика.  Вызов такой команды
выводит номер счётчика. При выводе номера раздела, плавающего объекта,
уравнения и тому подобного используются именно такого рода команды,
поэтому, переопределив \textcmd{the}-команду, можно немного изменить
стиль, например, следующая команда предписывает в~дальнейшем
маркировать все страницы в римском стиле:
\begin{lstlisting}[]
\renewcommand{\thepage}{\Roman{page}} 

\end{lstlisting}

На базе счётчиков можно организовывать иерархические структуры, то есть 
можно указывать зависимости:
\medskip

\begin{examplenv}[0.6\textwidth]{count-depend}
\newcounter{Main}\addtocounter{Main}{10} 
\newcounter{Dep}[Main]\addtocounter{Dep}{10} 
Было: \theMain.\theDep\par
\stepcounter{Main}
Стало: \theMain.\theDep
\end{examplenv}
\medskip

При создании нового счётчика можно создать связь с уже существующим,
указав имя существующего счётчика в качестве необязательного
параметра. В~примере выше счётчик \textcount{Dep} зависит от счётчика
\textcount{Main}. Эта связь проявляется в~том, что если увеличить
значение базового счётчика (\textcount{Main}) на единицу с помощью
команды \textcmd{stepcounter}, то подчинённый счётчик
(\textcount{Dep}) обнуляется. Обычно новый счётчик устанавливают в
подчинение счётчикам разделов (\textcount{section}). 

Стиль \textpkg{chngcntr} из пакета \textpkg{ltxmisc} позволяет
изменять зависимости уже после определения счётчика. Команда
\textcmd{counterwithin}\lstinline!{Dep}{Main}! привязывает счётчик
\textopt{Dep} к счётчику \textopt{Main}. Для обратного действия можно
воспользоваться командой
\textcmd{counterwithout}\lstinline!{Dep}{Main}!. Подробности можно
найти в конце стилевого файла \textfile{chngcntr.sty}.

Команда \textcmd{refstepcounter}\lstinline!{счётчик}! отличается от
\textcmd{stepcounter} тем, что помимо обнуления всех зависимых
счётчиков, \textcmd{refstepcounter} определяет значение, выводимое
командой ссылки \textcmd{ref}, как текст, создаваемый
\textcmd{the}-командой:
\begin{lstlisting}[]
% окружение "Задача"
\newcounter{Problem}[section]
\renewcommand{\theProblem}{\thesection.\arabic{Problem}}
\newenvironment{Problem}[0]{%
  \par\refstepcounter{Problem}%
  \theProblem\,}%
{\par}%

\end{lstlisting}
Здесь определено окружение \textenv{Problem} и одноимённый счётчик.
Счётчик \textenv{Problem} зависит от счётчика раздела. Вывод счётчика
\lstinline!\theProblem! переопределён как номер раздела, за которым
следует уже сам счётчик. Внутри окружения счётчик \textcount{Problem}
увеличивается на единицу с помощью команды
\lstinline!\refstepcounter{счётчик}!. Результат использования нового
окружения представлен в следующем примере:
\bigskip

% окружение "Задача"
\newcounter{Problem}[section]
\renewcommand{\theProblem}{\thesection.\arabic{Problem}}
\newenvironment{Problem}[0]{%
  \par\refstepcounter{Problem}%
  \theProblem\,}%
{\par}%
%precommand \newcounter{Problem}[section]
%precommand \renewcommand{\theProblem}{\thesection.\arabic{Problem}}
%precommand \newenvironment{Problem}[0]{%
%precommand   \par\refstepcounter{Problem}%
%precommand   \theProblem\,}%
%precommand {}%
%precommand \setcounter{chapter}{11}
%precommand \setcounter{section}{2}
\begin{examplenv}[0.55\textwidth]{problem-dop}
 \begin{Problem}\label{ex:1} 
   Задача раз 
 \end{Problem}
 \begin{Problem}\label{ex:2}
   Задача два 
  \end{Problem}
 Ссылки на раз~\ref{ex:1} и два~\ref{ex:2}.
\end{examplenv}


\section{Создаём свои \ldots}
\label{sec:prog:makecommands}

\ldots команды, окружения и прочее. Наверняка, возникшая в процессе
набора, простенькая надоедливая проблема решена и не один раз. С
другой стороны при~нарастающей квалификации проще бывает изобрести
велосипед заново в~удобной на текущий момент форме:
\begin{lstlisting}[emph={\xspace},emphstyle={\bfseries}]
\newcommand{\ee}{\ensuremath{e^{+}e^{-}}\xspace}

\end{lstlisting}
Часто новые команды создаются для комбинаций, используемых
исключительно в математическом окружении. Команда
\textcmd{ensuremath}  обеспечивает это окружение независимо от
текущего режима:
\bigskip

\begin{examplenv}{ee-prog}
\(J/\psi\to\ee\) является одним из
подвидов \ee{}"=рассеяния.
\end{examplenv}
\bigskip

Команда \textcmd{xspace} из одноимённого пакета \textpkg{xspace} добавляет в конце
команды пробел в случае, если за командой нет знаков препинания, то
есть избавляет от~необходимости самому вставлять явный пробел после
команды.

Имеются три команды, которые позволяют создавать свои или
переименовать уже имеющиеся макросы:
%emph={\providecommand},emphstyle={\bfseries}
\begin{lstlisting}[]
\newcommand{|<<команда>>|}[|N|][|<<зн. по ум.>>|]{|<<определение>>|}
\renewcommand{|<<команда>>|}[|N|][|<<зн. по ум.>>|]{|<<определение>>|}
\providecommand{|<<команда>>|}[|N|][|<<зн. по ум.>>|]{|<<определение>>|}

\end{lstlisting}

\textcmd{newcommand} определяет новую команду. Если такая команда
уже была, то при компиляции генерируется ошибка.
\textcmd{renewcommand} напротив переопределяет уже существующую
команду. В свою очередь \textcmd{providecommand} создаёт новую
команду, если на момент описания такой команды не было, и ничего не
делает, если она уже существовала.

В каждом из этих макросов есть два обязательных параметра "--- это имя
команды и её описание. Если команде необходимо передать
параметр/параметры, то первый необязательный аргумент должен принять
значение от одного (1) до~девяти (9). В разделе
\ref{sec:math:LaTeX-operands-hyphenations} обсуждалась команда для
дублирования знака в формуле при переносе её на следующую строку
(\lstinline!\(a + b \hm{=} c\)!):
\begin{lstlisting}[]
\newcommand*{\hm}[1]{#1\nobreak\discretionary{}%
  {\hbox{$\mathsurround=0pt #1$}}{}}

\end{lstlisting}

Вместо знака решётки (\textopt{\#}) с цифрой после него при компиляции
макроса подставляется соответствующий параметр. В данном случае
параметр был только один, и можно сказать, что его значение сохраняется
в <<переменной>> \textopt{\#1}. 

Звёздочка ($*$) в конце макроса \textcmd{newcommand}
налагает на передаваемый параметр команды \lstinline!\hm!
дополнительное условие: в передаваемом тексте не должно быть пустых
строк и команды \textcmd{par}. Иногда это упрощает
отладку кода.

Наличие второго необязательного параметра позволяет первый параметр
определить как параметр по умолчанию:
\medskip

\begin{examplenv}{sum-prog}
\newcommand{\exmpl}[1][умолчанию]%
                  {<<значение по #1>>}
Сравните \exmpl{} и \exmpl[требованию].
\end{examplenv}
\medskip


Для определения нового окружения используется команда
\textcmd{newenvironment}:
\medskip

\begin{examplenv}[0.5\textwidth]{rule-prog}
\newenvironment{outlined}%
       {\hrule\smallskip\begin{center}}%
       {\end{center}\smallskip\hrule}
\begin{outlined}
  Выделенный текст.
\end{outlined}
\end{examplenv}
\medskip

Формальное описание этой команды похоже на описание
\textcmd{newcommand}:
\begin{lstlisting}[]
\newenvironment{|<<окружение>>|}[|N|][|<<зн. по ум.>>|]%
                          {|<<код, открывающий окружение>>|}%
                          {|<<код, закрывающий окружение>>|}

\end{lstlisting}
Точно так же, как и в случае \textcmd{newcommand}, созданному
окружению можно передавать параметры. Подставлять параметры можно
только там, где в описании находится текст <<код, открывающий
окружение>>. Кроме команды создания нового окружения можно так же
переопределять уже имеющиеся окружения с~помощью аналогичной команды
\textcmd{renewenvironment}.

\subsection{Инструменты}
\label{sec:program:instrument}

\LaTeX{} "--- это надстройка над \TeX, и по"=хорошему, прежде чем
писать свои сложные макросы, следует проштудировать <<Всё про
TeX>>~\cite{Knuth-TeX} от мастера. Но уж очень это непростое занятие,
требующее значительных умственных и временных затрат. К~счастью, в
\LaTeX{} есть набор макропакетов, который облегчает жизнь
<<\LaTeX"=программиста"=новичка>>.

\subsection{Вычисления с calc}
\label{sec:program:calc}

В дополнение к стандартным возможностям пакет \textpkg{calc} из
коллекции \textpkg{tools} расширяет базовые операции с длинами и
счётчиками. Фактически \textpkg{calc} вводит арифметические операции в
привычной со школы инфиксной записи:
\medskip

\begin{examplenv}[0.6\textwidth]{calc-1}
Было до \theMyCount.\par
\setcounter{MyCount}{\value{MyCount}-1000}
Стало после \theMyCount.
\end{examplenv}
\medskip

При загрузке \textpkg{calc} \textcmd{setcounter},
\textcmd{addtocounter}, \textcmd{setlength} и \textcmd{addtolength}
переопределяются так, что в качестве аргумента  можно
передавать арифметические выражения. 
\medskip

%precommand \newlength{\MyLength}
\begin{examplenv}[0.6\textwidth]{calc-2}
\setlength{\MyLength}{
 (1em+\widthof{очень длинная фраза})*\real{1.2}}
\centering
\framebox[\MyLength]{очень длинная фраза}\par
\framebox[\MyLength]{короткая фраза}
\end{examplenv}
\medskip

Кроме арифметических операций в \textpkg{calc}
определяются макросы \textcmd{widthof}\lstinline!{текст}!,
\textcmd{heightof}\lstinline!{текст}!  и
\textcmd{depthof}\lstinline!{текст}! "--- ширина, высота и глубина
текста, переданного команде.

\begin{figure}[t]
  \centering%центрируем картинку
  \includegraphics{program/make-up-text-size.eps}
  \caption{Определение ширины (width), высоты (height) и глубины
    (depth)}\label{fig:program-text-size}
\end{figure}

Если используется пакет \textpkg{calc}, то при сложении и
вычитании данные должны быть однотипными, а при умножении длины на
число длина должна стоять до~числа (\textopt{4mm*2} "--- верно, а
\textopt{2*4mm} "--- не верно). Делить и умножать можно только на
целые числа. Действительные числа вводятся с помощью макроса
\textcmd{real} и отношения длин, вычисляемого с помощью команды:
\begin{lstlisting}
\ratio{|<<длина>>|}{|<<длина>>|}

\end{lstlisting}

Подробное описание пакета можно найти в его документации \textfile{calc.pdf}.

\subsection{Условные операторы и циклы}
\label{sec:prograpm:ifthenelse}

Простой условный оператор предоставляется пакетом \textpkg{xifthen},
который является улучшенной версией стандартного
\textpkg{ifthen}. Обучим считать компьютер от~одного до трёх по"=русски:
\medskip

\begin{examplenv}[0.6\textwidth]{ifthenelse-1}
\newcommand{\RusCnt}[1]{%
  \ifthenelse{\equal{#1}{1}}{раз}{}%
  \ifthenelse{\equal{#1}{2}}{два}{}%
  \ifthenelse{\equal{#1}{3}}{три}{}%
  \ifthenelse{\cnttest{#1}>{3}}{много}{}}
\RusCnt{1}, \RusCnt{2}, \RusCnt{3} и \RusCnt{4}.
\end{examplenv}
\medskip

В качестве первого аргумента макрос \textcmd{ifthenelse} принимает
тестовое условие,  в~случае его выполнения, выполняются команды второго
аргумента, а в случае не выполнения "--- третьего.

В примере сравнивается полученная строка текста с цифрами <<1>>, <<2>>
и <<3>> с~помощью макроса \textcmd{equal} "--- это с точки зрения
команды строки. Для того чтобы работать с этими строками как с
числами, в четвёртом операторе \textcmd{ifthenelse} используется тест
\textcmd{cnttest}\lstinline!{число}сравнение{число}!.  Этот тест в
качестве аргумента принимает строку в нотации пакета
\textpkg{calc}. Результатом выполнения каждого теста является булево
значение.

Стандартные тесты, определённые в пакете \textpkg{ifthen}.
\begin{itemize}
\item Сравнение целых чисел (\textcmd{value}\lstinline!{счётчик}! "---
  тоже целое число) с помощью операторов \(=\), \(>\) и \(<\).
\item \textcmd{isodd}\lstinline!{целое число}! "--- это число нечётное?
\item \textcmd{isundefinedcommand}\lstinline!{имя команды}! "--- эта
  команда не определена?
\item \textcmd{equal}\lstinline!{строка 1}{строка 2}! "--- эти строки равны?
\item \textcmd{boolean}\lstinline!{булево значение}! "--- это истина?
\item \textcmd{lengthtest}\lstinline!{длина 1 = длина 2}! "--- эти
  длины равны? Вместо знака равенства можно вставить знак больше \(>\)
  и меньше \(<\).
\end{itemize}

При составлении тестовых условий можно использовать \textcmde{(} и
\textcmde{)} в качестве символов группировки выражений, \textcmd{AND} "---
как логическое И, \textcmd{OR} "--- как ИЛИ и \textcmd{NOT} "--- как
логическое отрицание.

В \textpkg{xifthen}  определены дополнительные тесты.
\begin{itemize}
\item \textcmd{isnamedefined}\lstinline!{имя команды}! "--- эта
  команда определена?
\item \textcmd{isempty}\lstinline!аргумент! "--- аргумент пустой?
\item \textcmd{isequivalentto}\lstinline!{команда 1}{команда 2}! "---
  эти команды эквивалентны?
\item \textcmd{cnttest}\lstinline!{выражение 1}сравнения{выражение 2}!
  "--- сравнение двух \textpkg{calc}"=подобных числовых выражений.
\item \textcmd{dimtest}\lstinline!{выражение 1}сравнения{выражение 2}!
  "--- сравнение двух \textpkg{calc}"=подобных выражений типа <<длина>>.
\end{itemize}

Также в пакете добавлена возможность определения своих
тестов. Для выяснения подробностей следует посмотреть в документацию
\textfile{xifthen.pdf}.

Кроме условных выражений в пакете \textpkg{ifthen} определён цикл
\textcmd{whiledo}:
\begin{example}[0.55\textwidth]{ifthenelse-1}
\def\Source{ Это , короткий , тест } 
\whiledo{\not\equal{\Source}{}}
{ \GetTokens{TokenOne}{TokenTwo}{\Source}%
  \fbox{\TokenOne}%
  \let\Source\TokenTwo}
\end{example}
Первый аргумент команды цикла представляет из себя тестовое выражение,
а второй "--- действие, которое выполняется, пока первый аргумент не ложный.

Для создания примера использовался макрос \textcmd{GetTokens} из
пакета \textpkg{tokenizer}, который разбирает текстовый список. По
умолчанию разделителем такого списка является запятая. Первому аргументу
макроса присваивается первый элемент списка, второму "--- остаток, а
третьему передаётся сам список. Подробности можно найти в~файле
\textfile{tokenizer.pdf}.




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../ctex"
%%% End: 
