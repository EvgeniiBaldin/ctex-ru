%  -*- coding: koi8-r -*-
\chapter{Базовые элементы}
\label{cha:base}

% {\setlength{\epigraphwidth}{0.6\textwidth}
%   \epigraph{  Объявление в газете: Ищу работу машинистки.\\ 
%   Печатаю со скоростью 4000 знаков в минуту. \\
%   Правда, такая белиберда получается!}{Автор неизвестен}}

{\setlength{\epigraphwidth}{0.63\textwidth} \epigraph{Не надо пытаться
    \emph{приблизиться} к лучшим книгам, надо пройти весь путь до
    конца и сделать эти книги!}{\emph{Дональд Э.\,Кнут}}

Самое главное "--- это сам текст, но для его адекватного представления
необходимо немного потрудиться. Надо дать правильные команды
компьютеру.


% Мы говорим на русском языке и пользуемся операционной системой
% GNU/Linux "--- подобное на нашей планете не так уж и часто встретишь.
% Хотите стать ещё более элитарным подмножеством? Используйте \LaTeX{}
% \smiley!


\section{<<Командная логика>>}
\label{sec:command}

% \begin{flushright}
%   Щенок должен понять, \\
%   что быстрое и чёткое выполнение команд хозяина\\
%   всегда вознаграждается лакомством или лаской.
% \end{flushright}
\mindexemph{команды!\LaTeX|(}


Для набора кода в \LaTeX{} знание английского языка приходится очень
кстати. Основных команд немного, и их можно запомнить и так, но для
совершенствования английский необходим, хотя бы для чтения
документации к пакетам. Названия у~команд, как правило, вполне
осмыслены, что очень помогает при поиске необходимой информации в
алфавитном указателе. <<Правильный>> текстовый редактор тоже не
является лишним.

\paragraph{Спецсимволы.}
\label{sec:base:command:symbol}
\mindex{спецсимволы|(}
Не все символы  равноправны. За частью символов в \LaTeX{}
зарезервированы специальные значения.

Это: <<\bs>>, <<\$>>, <<\%>>, <<\_>>, <<\{>>, <<\}>>, <<\&>>, <<\#>>,
<<\^{}>> и <<\~{}>>. В процессе изложения их роль будет со временем
раскрыта. Набиралось это так:
\begin{lstlisting}[]
Это: <<\textbackslash>>, <<\$>>, <<\%>>, <<\_>>|\footnote{Можно воспользоваться пакетом \textbf{underscore} "--- в этом случае необходимость экранировать знак <<_>> в текстовой моде  отпадает.}|, <<\{>>, 
<<\}>>, <<\&>>, <<\#>>, <<\^{}>> и <<\~{}>>. В процессе 
изложения их роль будет раскрыта. Набиралось это так:

\end{lstlisting}
% Чтобы отобразить эти специальные символы как они есть на самом деле
%  при печати необходимы дополнительные усилия.


\mindex{спецсимволы|)}

\paragraph{Группировка.}
\label{sec:base:command:group}

\mindexemph{группировка|(}


Группировка множества символов осуществляется с помощью фигурных скобок:
\lstinline!{ группа }!. Фигурные скобки при печати не отображаются.

Сложные конструкции, которые имеют открывающую и закрывающую команды,
тоже группируют текст.

\mindexemph{группировка|)}

\paragraph{Построение команды.}
\label{sec:base:command:skelet}

Команды в \LaTeX{} начинаются с символа <<\bs>> (backslash или
обратная косая черта) и продолжаются комбинацией, состоящей только 
из~латинских букв.
% \footnote{Это верно для стандартной
%   кириллизации. Существуют варианты русификации, например, русификация
%   Шеня, где русские буквы также могут входить в имена команд.}.
Команды завершаются пробелом, цифрой или не латинской буквой. Все
пробельные символы после команды игнорируются. Для того чтобы пробел
после команды не игнорировался, достаточно вставить <<пустую группу>>:
\lstinline!\command{}!. Например, чтобы лого \LaTeX{} (команда
\textcmd{LaTeX}) не слилось со~следующим за ним словом, следует
написать \textcmd{LaTeX}\lstinline!{}!.
\vspace*{-0.5em}


\paragraph{Аргументы.}
\label{sec:base:command:arguments}

\mindexemph{аргументы команд|(}


Командам \LaTeX{} могут передаваться внешние аргументы:
\smallskip

\begin{lstlisting}[]
\command[param1][param2]{param3}{param4}

\end{lstlisting}
В квадратные скобки заключаются необязательные параметры
(\textopt{param1} и \textopt{param2}), а в фигурные "--- обязательные
(\textopt{param3} и \textopt{param4}).

Некоторые команды \LaTeX{} влияют только на свои аргументы.
Например, команда \textcmd{textbf}\lstinline!{текст}! печатает
<<текст>> жирным шрифтом.

\mindex{перемещаемые параметры}
\Note Отдельные команды  \LaTeX{} имеют \emph{перемещаемые
  параметры}, содержимое которых используется для оформления
колонтитулов или заносится во внешние файлы для формирования разного
рода списков и поддержания ссылочного механизма. Примерами таких команд
являются все команды рубрикации: \textcmd{chapter}, \textcmd{section},
\textcmd{subsection} и так далее.

\mindex{хрупкие команды}
Некоторые команды \LaTeX{} нельзя использовать в перемещаемых
параметрах "--- такие команды называются \emph{хрупкими}. Большинство
команд с необязательными аргументами являются хрупкими. Если же
всё-таки использовать такую команду в перемещаемом аргументе
необходимо, то непосредственно перед ней при~помещении в аргумент
нужно добавить команду \textcmd{protect}. Например, так:
\smallskip

\begin{lstlisting}[]
|\bs|subsection{Заголовок\protect\footnote{Сноска}}

\end{lstlisting}
\vspace*{-1em}

\mindexemph{аргументы команд|)}
\paragraph{Декларативные команды.}
\label{sec:base:command:declare}
Часть команд \LaTeX{} являются своеобразными переключателями режимов.

Область действия декларативной команды может ограничиваться логической
группой или единицей структуры печатного документа, например,
страницей. Примеры декларативных команд:
\begin{lstlisting}[]
% Дальнейший текст будет печататься жирным шрифтом
\bfseries
% Убрать заголовки и нумерацию для текущей страницы
\thispagestyle{empty}

\end{lstlisting}


\paragraph{Окружения.}
\label{sec:base:command:environment}
\mindexemph{окружение|(}

Сложные конструкции, которые имеют открывающую и закрывающую команды
вида \textcmd{begin}\lstinline!{имя}! и \textcmd{end}\lstinline!{имя}!,
называют окружениями. Вместо слова <<имя>> подставляется название
соответствующего окружения:
\begin{lstlisting}[]
\begin{center}
Эта строка будет центрирована
\end{center}

\end{lstlisting}

Окружения могут вкладываться друг в друга, как матрёшки, но их области
действия не могут перекрываться.

\mindexemph{окружение|)}

\mindexemph{команды!\LaTeX|)}


\section{Логика документа}
\label{sec:base:doclogic}

Вид документа определяется выбором класса и стилей. Хорошим приёмом
является наличие личных готовых шаблонов с уже предопределёнными
предпочтениями, которые могут меняться по мере развития документа.

\subsection{Структура \LaTeX-файла}
\label{sec:struct}
Текстовый tex-файл состоит из двух частей: преамбулы и, собственно,
самого текста. Выглядит он примерно следующим образом:
\begin{lstlisting}[]
%---начало преамбулы---
% Выбор класса документа, например, article или book
\documentclass[a4paper,12pt,oneside]{scrartcl} 
% Минимальная кириллизация - кодовая страница документа
\usepackage[koi8-r]{inputenc}
% Локализация и переносы
\usepackage[english,russian]{babel}
\usepackage{indentfirst}
\usepackage{misccorr}
% Загрузка пакетов по выбору
\usepackage{|\ldots|}
   |\ldots|
% Определение новых или переопределение старых команд 
\newcommand{\mycommand}{|\ldots|}
\renewcommand{\oldcommand}{|\ldots|}
   |\ldots|
% Локальные настройки
   |\ldots|
%---конец преамбулы---
\begin{document}
% Тело документа
\end{document}

\end{lstlisting}

Первым делом с помощью инструкции \textcmd{documentclass}
осуществляется выбор класса документа. Далее с помощью команд
\textcmd{usepackage} загружаются стилевые пакеты.

Для того чтобы можно было набирать русский текст, необходимо с помощью
пакета \textpkg{inputenc} указать кодировку текстового файла,
например, \textcodepage{koi8-r}\footnote{\textcodepage{koi8-r} "---
  русская 8-битная кодировка традиционно используемая в UNIX-подобных
  операционных системах. Имеет свой RFC  1489.},
\textcodepage{cp866}\footnote{\textcodepage{cp866} или
  \textcodepage{альтернативная кодировка} "--- русская 8-битная
  кодировка, используемая для~набора текстов в DOS и OS/2.},
\textcodepage{cp1251}\footnote{\textcodepage{cp1251} или
  \textcodepage{Windows-1251} "--- стандартная 8-битная кодировка для
  всех русских версий Microsoft Windows.} или
\textcodepage{utf8}\footnote{UTF-8 (Unicode Transformation Format)
  "--- распространённая кодировка, реализующая представление
  Юник\'ода.}  (Unicode). 

Далее нужно подключить пакет \textpkg{babel}, который отвечает за
локализацию, в~частности за настройку переносов и <<национальные
особенности>> набора. Например, при включении русского языка
доопределяется символ параграфа \S{} (\textcmd{S}) и многое другое. 

%\No{} (\textcmd{No}) 

Для формирования отступа или красной строки у первого параграфа, как
это принято в России, необходимо загрузить пакет
\textpkg{indentfirst}.  По идее, это должно относиться к <<национальным
особенностям>>, но в \textpkg{babel} по умолчанию не
подгружается. Загрузка стиля \textpkg{misccorr} также исправляет ещё
некоторое количество недоработок \textpkg{babel}.


\paragraph{К вопросу о переносах.}
\label{sec:base:hyphen}

\mindex{перенос слов|(}
\mindex{русификация|(}

Пожалуй, единственное, что может потребовать настройку в
свежеустановленном дистрибутиве \LaTeX "--- это включение переносов. Данная
проблема заведомо не возникает при установке \TeXLive и в большинстве
современных дистрибутивах, но всякое бывает.

Для установки переносов необходимо отредактировать файл
\textfile{language.dat} и перегенерировать все имеющиеся форматные
файлы (fmt-файлы). Это проще всего сделать через стандартные
утилиты настройки, например, в MiKTeX это делается с помощью программы
<<MiKTeX Options>>\footnote{Выбор таблиц переносов осуществляется на
  закладке \textmenu{Languages}. После этого на закладке
  \textmenu{General} следует нажать кнопку \textmenu{Update Now} для
  перегенерации форматных файлов.}, а в среде GNU/Linux можно
воспользоваться утилитой
\textprog{texconfig}\footnote{\textprog{texconfig} "--- это
  простенькое dialog-подобное консольное приложение. Некоторые
  настройки могут потребовать привилегии суперпользователя. После
  изменения настроек через \textprog{texconfig} автоматически
  перегенерируются необходимые форматные файлы. В противном случае
  может потребоваться сделать это вручную, например, с помощью
  инструкции вида: \textprog{texconfig init}.}.  После запуска
программы следует выбрать меню \texttt{HYPHENATION}, а затем меню
\textprog{latex}. Далее будет предложено
отредактировать\footnote{Редактор можно определить с помощью
  переменной окружения \texttt{\$EDITOR}.  Если переменная не
  определена, то вызывается редактор \textprog{vi}. В случае
  отсутствия опыта работы с \textprog{vi}, следует выйти из него с
  помощью последовательности \texttt{:q} и настроить переменную
  окружения на~известный редактор или разобраться с
  \textprog{vi}.}  файл переносов \textfile{language.dat}. Обычно
достаточно таких настроек:
\begin{lstlisting}[language=bash]
english hyphen.tex
russian ruhyphen.tex

\end{lstlisting}
Всё остальное по желанию можно закомментировать. За переносы отвечает
пакет \textpkg{babel}. По умолчанию, когда включаются переносы для
определённого языка, все остальные правила переносов отключаются. Но в
случае английского и русского языков это можно обойти,
воспользовавшись русско-английской таблицей переносов:
\begin{lstlisting}[language=bash]
ruseng ruenhyph.tex
=russian
=english

\end{lstlisting}
Следует понимать, что подобная настройка с точки зрения философии
\LaTeX{} не совсем корректна. Для гарантированно одинакового
результата компиляции независимо от платформы лучше поступиться 
некоторыми удобствами.

\mindex{русификация|)}
\mindex{перенос слов|)}

\subsection{Класс документа}
\label{sec:base:class}
\mindex{класс|(}

С помощью обязательной инструкции
\textcmd{documentclass}\lstinline![опции]{класс}! указывается, к какому
классу будет относиться рабочий текст.

Класс документа следует выбирать в зависимости от того, что должен 
из~себя представлять результирующий документ. Для начала, в принципе, можно
остановиться на стандартном классе \textpkg{article}. Этот класс
разработан специально для~статей и небольших отчётов. Для отчётов
побольше можно использовать класс \textpkg{report}, а для книг  "--- класс
\textpkg{book}.

Перечисленные стандартные классы сложились очень давно, и многие
производные классы документов основаны на них. Как следствие
стандартные базовые классы абсолютно статичны и имеют массу
недостатков, которые из-за требований совместимости исправить не
получается. 

Для специализированных задач используются свои классы. Например, 
для~научных статей популярны различные модификации \textpkg{revtex4}.
Константин Кориков разработал и активно поддерживает класс
\textpkg{eskdx} (стандарт ЕСКД), который можно найти на CTAN или в
стандартной поставке \TeXLive.  Те, кого <<напрягают>> большие поля в
стандартных \LaTeX-классах, могут обратить внимание на набор классов
\textpkg{KOMA-Script}: \textpkg{scrartcl}, \textpkg{scrreprt} и
\textpkg{scrbook} вместо \textpkg{article}, \textpkg{report} и
\textpkg{book} соответственно.

По началу в выбранном классе ничего менять не следует. То, что кажется
с~непривычки неудобным, на самом деле может улучшить восприятие 
печатной копии.  Например, относительно узкая ширина текста в стандартных классах
(следствие больших полей) позволяет при прочтении охватывать взглядом
всю строку целиком, что немного увеличивает скорость чтения. А сами
большие поля можно использовать для заметок. 

Обычно разумные модификации можно выбирать с помощью передачи
параметров при выборе класса, например, так:
\begin{lstlisting}
\documentclass[a4paper,12pt,oneside]{scrbook} 

\end{lstlisting}
где \textopt{a4paper} "--- размер листа бумаги (можно выбрать другой
стандартный размер, например, \textopt{a5paper}), \textopt{12pt} "--- базовый
размер шрифта (в стандартных классах доступны размеры в \textopt{10pt}
и \textopt{11pt}), а \textopt{oneside} "--- односторонняя печать (удобнее
при просмотре электронной версии).


В заключении этого раздела хотелось бы отметить пакет \NCC,
который активно разрабатывается А.\,И.~Роженко. Класс \textpkg{ncc}
позиционируется автором как <<русскоязычная статья>>. Класс можно
взять на CTAN, он также присутствует в~стандартной поставке
\TeXLive.

\mindex{класс|)}

\subsection{Стили}
\label{sec:base:styles}

\mindex{стиль|(}

Стилевой файл (\textext{sty}) или пакет представляет собой набор
макросов и определений, созданных для решения какой-то определённой
задачи. Для подключения стилевого файла используется команда
\textcmd{usepackage}\lstinline![опции]{стиль}!.  

Основное отличие классов от стилей в том, что на документ может быть
ровно один класс и сколько угодно стилей. Фактически на любую задачу в
\LaTeX{} находится ответ в виде соответствующего пакета. В стандартной
поставке \TeXLive присутствует свыше двух тысяч
sty-файлов. Кроме того, ничего не мешает создать свой
собственный стиль, предназначенный для решения своих локальных
проблем. Хотя всегда лучше воспользоваться \emph{уже} готовыми
решениями.

\mindex{стиль|)}

\paragraph{К вопросу о русификации.}
\label{sec:base:cyr}
\mindex{русификация|(}
Чтобы кириллизовать \LaTeX, необходимы шрифты. Благодаря Ольге Лапко
на свете есть шрифты семейства \textpkg{lh}, которые отлично
согласуются с базовыми шрифтами Computer Modern. Мало иметь просто
кириллические буквы "--- надо, чтобы их начертания соответствовали и
другим шрифтам, в том числе и математическим. В 2001 году Владимир
Волович проделал огромную работу по переводу \METAFONT-шрифтов в
формат Type1. Благодаря ему теперь можно создавать не только хорошие
печатные копии, но и вполне качественные электронные pdf"=версии
документов.

За перевод из кодировки пользователя во внутреннюю кодировку \LaTeX{}
отвечает пакет \textpkg{inputenc}. В качестве опции при загрузке с ним
передаётся текущая восьмибитная кодовая страница документа. Для
русскоязычной кириллицы могут оказаться интересны следующие варианты:
\textcodepage{koi8-r}, \textcodepage{cp866}, \textcodepage{cp1251} и
\textcodepage{utf8}. Собственно говоря, всё. Единственное неудобство,
возникающее из-за этого, заключается в~том, что сообщения об ошибке
\LaTeX{} выдаёт в своей внутренней
\textcodepage{T2A}"=кодировке\footnote{Расположение букв похоже на
  расположение букв в \textcodepage{cp1251}, но полностью не совпадает
  "--- чистая случайность.}. Для исправления данного неудобства можно
воспользоваться простейшим фильтром \textprog{t2filter}. Для начала
его надо собрать.

Примерный алгоритм поиска и сборки фильтра:
\begin{lstlisting}[language=bash,escapechar=,frame=]
> locate t2filter.c
{TEXMF}/texmf-dist/doc/generic/t2/etc/t2filter.c
> cd {TEXMF}/texmf-dist/doc/generic/t2/etc/
> gcc -Wall -O2 -s -o ~/bin/t2filter t2filter.c
> latex {файл}.tex | t2filter

\end{lstlisting}

\mindex{русификация|)}

\subsection{Тело документа}
\label{sec:base:body}

Всё, что заключено внутри окружения \textenv{document}, является телом
документа. Если у вас есть какие-то куски текста, которые печатать не
хочется, а выкинуть жалко, то их достаточно вынести в самый конец за
инструкцию \textcmd{end}\lstinline!{document}!.

\section{Логика набора}
\label{sec:base:nabor}


% \begin{flushright}
%   Объявление в газете: Ищу работу машинистки.\\ 
%   Печатаю со скоростью 4000 знаков в минуту. \\
%   Правда, такая белиберда получается!
% \end{flushright}

Мало открыть файл в текстовом редакторе и начать набирать. Нажимать 
на~клавиши надо осмысленно.



\subsection{Печатаем текст}
\label{sec:print}


При наборе книги/статьи/заметки основное "--- вовсе не команды, а сам
текст. Правила очень просты.

\paragraph{Комментарии.}
\label{sec:base:comment}

\mindexemph{комментарий|(}


Всё, что следует за знаком <<\%>> включительно, является комментарием.

Большие закомментированные сегменты мешают работать с основным
текстом, и поэтому их следует исключать из рабочего файла. Но при
желании можно воспользоваться окружением \textenv{comment} из
пакета \textpkg{verbatim}.

\mindexemph{комментарий|)}


\paragraph{Разделение слов.}
\label{sec:base:space}
\mindex{пробелы|(}


Пробельные символы используются в \LaTeX{} для разделения слов.
Пробелы в начале строки игнорируются. Символ перевода строки также
воспринимается как пробел. Если в конце строки сразу за последним
словом вставить знак комментария:
\begin{lstlisting}[]
экранировка перевода стр%
     оки

\end{lstlisting}
то разделения слов не происходит "--- экранировка пробелов. Иногда
этот приём может оказаться полезным.

\mindex{пробелы|)}

\paragraph{Разделение абзацев.}
\label{sec:base:nabor:abzac}
\mindex{абзац|(}

Для того чтобы начать следующий абзац, необходимо оставить пустую
строку:
\begin{lstlisting}[]
текущий абзац закончился

следующий абзац начался\par
\end{lstlisting}

Число пустых строк между абзацами не имеет значения. Пустая строка
эквивалентна команде \textcmd{par}:
\begin{lstlisting}[]
текущий абзац закончился\par
следующий абзац начался
\end{lstlisting}

\mindex{абзац|)}



\paragraph{Выделение текста.}
\label{sec:base:textemph}
Самый простой способ выделения текста "--- это смена насыщенности или
начертания шрифта. Как правило, для выделения конкретных слов и фраз
достаточно команды \textcmd{emph}, но возможны и другие варианты:


\textcmdh{textbf}\textcmdh{textsc}\textcmdh{textit}\textcmdh{textsl}
\begin{examplenv}[0.55\textwidth]{base-textemph-1}
\emph{Внимание!:} \textbf{жирный шрифт},
\textit{курсив}, \textsc{Капитель},
\textsl{наклонный шрифт} и обычный текст.
\end{examplenv}

Для каждой команды выделения текста есть декларативные альтернативы:
\textcmd{bfseries} "--- \textbf{жирный текст}, \textcmd{itshape} "---
\textit{курсив}, \textcmd{scshape} "--- \textsc{капитель} и
\textcmd{slshape} "--- \textsl{наклонный шрифт}. 

Для получения жирных \textbf{\textit{курсива}},
\textbf{\textsc{капителя}} и \textbf{\textsl{наклонного}} текстов инструкции
смены начертания и насыщенности можно комбинировать, например:
\begin{examplenv}[0.6\textwidth]{base-textemph-2}
\textbf{\textit{жирный курсив}}\par
\textbf{\textmd{\textit{просто курсив}}}
\end{examplenv}
В этом примере команда \textcmd{textmd} задаёт среднюю, то есть обычную,
насыщенность текста, как бы отменяя действие инструкции \textcmd{textbf}.

Результат воздействия команды \textcmd{emph} зависит от
текущего начертания:\textcmdh{itshape}
\begin{examplenv}[0.6\textwidth]{base-textemph-3}
{\itshape курсивная среда  \emph{выделение}}
\end{examplenv}

\begin{table}[t]
  \centering
  \begin{tabular}[h]{lcc}\hline
    \cbox{Декларация} & \cbox{Строчный образец} &  \cbox{Заглавный образец}\\\hline
    \textcmd{tiny} & {\tiny образец} &  {\tiny ОБРАЗЕЦ}\\
    \textcmd{scriptsize} & {\scriptsize образец} & {\scriptsize ОБРАЗЕЦ}\\
    \textcmd{footnotesize} & {\footnotesize образец} & {\footnotesizeОБРАЗЕЦ}\\
    \textcmd{small} & {\small образец} & {\small ОБРАЗЕЦ}\\
    \textcmd{normalsize} & {\normalsize образец} & {\normalsize ОБРАЗЕЦ}\\
    \textcmd{large} & {\large образец} & {\large ОБРАЗЕЦ}\\
    \textcmd{Large} & {\Large образец} & {\Large ОБРАЗЕЦ}\\
    \textcmd{LARGE} & {\LARGE образец} & {\LARGE ОБРАЗЕЦ}\\
    \textcmd{huge} & {\huge образец} & {\huge ОБРАЗЕЦ}\\
    \textcmd{Huge} & {\Huge образец} & {\Huge ОБРАЗЕЦ}\\\hline
  \end{tabular}
  \caption{Команды переключения размеров шрифта}
  \label{tab:base:fontsize}
\end{table}

Ещё один способ визуального разделения текста "--- изменение размера
шрифта. Для смены размера используются декларативные команды.
Базовому размеру шрифта обычного текста соответствует декларация
\textcmd{normalsize}. В таблице~\ref{tab:base:fontsize} представлен
список команд переключения размеров.

\Note{} По умолчанию для набора текста используется прямой шрифт средней
насыщенности семейства Roman. При желании можно заказать
\textsf{рубленый шрифт} (\textsf{Sans Serif}) c помощью команды
\textcmd{textsf} или \texttt{машинописный} (\texttt{Typewriter}) с помощью
команды \textcmd{texttt}.



\paragraph{Перечни.}
\label{sec:base:nabor:itemize}
\mindex{перечень|(}


Для создания многоабзацных нумерованных перечислений используется
окружения \textenv{enumerate}, а для ненумерованных
\textenv{itemize}. Перечни можно вкладывать друг в
друга для получения многоуровневых перечислений.

\begin{example}[0.48\textwidth]{base-itemize}
Перечни по своей структуре бывают:
\begin{enumerate}
 \item внутриабзацными:
  \begin{inparaenum}
   \item раз, \item два, \item три.
  \end{inparaenum}
 \item многоабзацными. \par
  В свою очередь многоабзацный 
  перечень  может быть: 
  \begin{itemize}
   \item нумерованным,
   \item ненумерованным.
  \end{itemize}
\end{enumerate}
\end{example}
Для разделения пунктов перечней используется декларация
\textcmd{item}, которая формирует правильный отступ и ставит
соответствующую метку.

Внутриабзацные перечисления реализуются с помощью окружений
\textenve{inparaenum} и \textenv{inparaitem} из пакета
\textpkg{paralist} (подробности на
стр.~\pageref{sec:base-2:paralist}).  


\mindex{перечень|)}


\subsection{Пунктуация}
\label{sec:base:punctuation}
\mindexemph{пунктуация|(}
Напечатанный текст обезличивается. Нет эмоций "--- только
буквы. Единственное, что остаётся "--- это знаки пунктуации и,
возможно, смайлики \smiley.

Запятую, точку, точку с запятой, двоеточие, многоточие, скобки,
кавычки, восклицательный и вопросительные знаки следует <<прижимать>>
к словам. Не надо оставлять пробелов, а то \LaTeX{} <<подумает>>, что
так и надо.

\paragraph{Пробелы.}
\label{sec:base:punctuation:space}
\mindex{пробелы|(}

Расстояние между словами \LaTeX{} выбирает по своему усмотрению для
максимально равномерного заполнения абзаца. Но иногда необходимо
указать размер пробела руками:
\medskip
\begin{eqlist*}
\item[\fbox{\~{}}] "--- неразрывный пробел, то есть по этому пробелу не
  производится перенос предложения на другую строку;
\item[\fbox{\bs,}] "--- маленький нерастяжимый пробел;
\item[\fbox{\bs\textvisiblespace}] "--- нормальный пробел.
\end{eqlist*}
\begin{example}[0.49\textwidth]{base-spaces-1}
В основном, указывать размеры пробелов 
надо в случае набора каких"=либо 
сокращений, например, так следует 
набирать ФИО:  Ф.\,А.~Милия "--- 
негоже <<отрывать>> ИО от Ф\@. 
Ещё примеры: т.\,е. (не т.е.), 
г.~Новосибирск, рис.~1 и~т.\,д.\ 
и~т.\,п.
\end{example}

\LaTeX{} считает, что после точки предложение заканчивается, если эта
точка стоит не после заглавной буквы. Растяжимость пробелов между
предложениями и между словами существенно разная. Поэтому если точка
случается в середине предложения, то после неё следует явно вставить
пробел <<\lstinline!\!\textvisiblespace>> или неразрывный пробел
<<\lstinline!~!>>. Может случиться так, что точка следует сразу за
заглавной буквой (как в примере происходит с буквой Ф), но означает
именно конец предложения. Для этого перед такой точкой следует
добавить коррекцию в виде команды <<\lstinline!\@!>>.

Если часть слова набрана наклонным шрифтом, а часть прямым, то
необходимо вставить специальный корректирующий пробел \lstinline!\/!
\begin{example}{base-spaces-2}
Сравните: {\LARGE {\itshape Г}рош} и 
          {\LARGE {\itshape Г}\/рош}.
\end{example}
Такое ухищрение нужно только в случае, если выделение текста осуществляется с
помощью декларативных команд. Если используются команды, в которых
текст  передаётся в качестве аргумента, то корректирующий
пробел вставляется автоматически.

\mindex{пробелы|)}

\paragraph{Дефисы, минусы и тире.}
\label{sec:base:punctuation:dash} 
\mindex{дефис}
\mindex{минус}
\mindex{тире}

В издательских системах, основанных на \TeX, различают дефис <<->>
(hyphen), короткое тире <<-->> (en-dash), длинное тире <<--->>
(em-dash) и знак минуса <<$-$>>.

Чтобы получить на печати дефис, короткое или длинное тире, надо
набрать один, два или три знака <<->> соответственно.

При подключении пакета \textpkg{babel} с опцией \textopt{russian}
появляются дополнительные команды, позволяющие более строго следовать
русским печатным традициям:

\begin{lstlisting}[]
Дефис используют в составных словах (кто-то, где-нибудь), 
короткое тире рекомендуется для указания диапазона чисел 
(10--15, 2001--2006), длинное тире означает обычное тире 
(\LaTeX{} "--- это круто), минус может существовать только 
в формулах ($a-b=c$).

Между собственными именами следует использовать 
команду "--~, например, уравнение Клапейрона"--~Менделеева. 
Также тире ставится между словами для обозначения пределов,
например, поезд Москва"--~Новосибирск или отпуска 
в июле"--~августе. Чтобы длинное тире не отрывалось 
от предыдущего слова и вокруг него создавались правильные 
пробелы вместо --- следует употреблять "---, т.\,е. к трём 
тире надо добавить двойную кавычку. Прямая речь должна 
начинаться с команды "--*:

"--* Я сказал.

\end{lstlisting}

Правила могут показаться немного запутанными, но к ним быстро
привыкаешь, и они того ст\'оят.


\paragraph{Переносы.} 
\label{sec:base:punctuation:hyphen} 
\mindex{перенос слов|(}

Как правило, \LaTeX{} грамотно переносит
слова. Но в случае сложных слов, которые пишутся через дефис, перенос
происходит только по дефису. Аналогично, проблемы возникают, когда слово
частично состоит из английских букв, а частично из кириллицы.

\begin{lstlisting}[]
Прямо в тексте перенос можно указать с помощью команды \-, 
например: дель\-та-функ\-ция, \TeXно\-ло\-гия.

При наличии русского языка в \textbf{babel} вместо дефиса 
в сложном слове можно поставить команду "=, например, 
дельта"=функция. В этом случае переносы будут сделаны 
корректно без подсказки.

\end{lstlisting}

Для часто упоминаемых слов можно задать шаблон переносов с помощью
команды
\textcmd{hyphenation}\lstinline!{образ-цы пе-ре-но-са дель-та=-функ-ция}!.
Как правило, образцы переноса лучше определять в заголовке документа.
Следует понимать, что образцы автоматически не склоняются, поэтому
надо предусмотреть всевозможные варианты окончаний.

С помощью команды \textcmd{hyphenation} можно запретить перенос
слова в нежелательных местах, просто не указав место разрыва. В тексте
запрет переноса можно оформить с помощью инструкции
\textcmd{mbox}\lstinline!{эта фраза не переносится}!.
\mindex{перенос слов|)}

\paragraph{Многоточие.}\mindex{многоточие} Многоточие печатается с помощью команды
\textcmd{ldots}. Если многоточие идёт после точки, то необходимо
вставить неразрывный пробел \lstinline!~! (знак тильды).



\paragraph{Ударение.}\mindex{ударение} 
В русском языке длительность ударного гласного примерно в 1.5--2 раза
длиннее безударного. Если ударение поставить не в том месте, то слово
будет звучать совсем по другому.

\begin{lstlisting}[]
В корне \textbf{зар-} --- \textbf{зор-} под ударением 
пишется гласная в соответствии с произношением, без ударения 
"--- \textbf{а}: з\textbf{\'а}рево, з\textbf{\'о}рька "---
з\textbf{а}рн\'ица, оз\textbf{а}р\'ять

Исключения: з\textbf{о}р\'янка, з\textbf{о}рев\'ать.

\end{lstlisting}



\paragraph{,,Лапки`` и <<Ёлочки>>.}%''
\label{sec:base:punctuation:lapki-yolochki}
\mindexemph{кавычки|(}
В пакете \textpkg{babel}, кроме всего прочего, определены традиционные
русские кавычки, а точнее: ,,лапки`` %''
 (немецкие кавычки) и <<ёлочки>>
(кавычки французские):
\begin{lstlisting}[]
Если в начале или в конце текста встречаются внутренние и 
внешние кавычки, то они должны различаться между собой 
рисунком.

Он сказал: <<А пойду-ка я и подпишусь на ,,Linux Format``>>.

\end{lstlisting}


\mindexemph{кавычки|)}

\mindexemph{пунктуация|)}

\section{Структурная логика}
\label{sec:base:basestruct}

\LaTeX{} ориентирован на логическую разметку документа. Можно, конечно,
<<сказать>>, что данный кусок текста следует напечатать размером 20
пунктов, выровнять по левому краю и сделать отступ после него в полтора
интервала, но проще указать, что это заголовок раздела.

\subsection{Титульный лист}
\label{sec:base:title}
\mindex{титульный лист|(}

Создание титульного листа "--- это отдельная задача, в которой визуальная
составляющая обычно превалирует над структурной. В этом случае следует
воспользоваться окружением \textenv{titlepage}. При инициализации этого
окружения  создаётся чистая страница, которой присваивается номер
один, а содержание этой страницы полностью определяется фантазией
автора. Но в любом случае это следует делать уже после написания самого
текста. Как правило, в начале достаточно стандартного заголовка:
\begin{lstlisting}[]
\title{\LaTeX, Unix и русский стиль}
\author{Е.\,М.~Балдин\thanks{e-mail: E.M.Baldin@inp.nsk.su}}
\date{2002}
\maketitle

% Только для производных класса article
\begin{abstract}
  В статье говорится про \LaTeX, Unix и русский стиль.
\end{abstract}
\end{lstlisting}

Команда \textcmd{maketitle} создаёт стандартный титульный заголовок,
используя информацию о названии документа (\textcmd{title}),
авторе (\textcmd{author}) и дате написания текста
(\textcmd{date}). Команда \textcmd{thanks} правильным образом
позволяет оформить подстрочное примечание на титульной странице. Если
авторов более чем один, то их можно перечислять, разделяя командой
\textcmd{and} "--- в этом случае список авторов печатается в виде
таблицы.

В статьях (производные от класса \textpkg{article}) вслед за заголовком
следует обязательная аннотация, которая оформляется с помощью
окружения \textenv{abstract}. 

В книгах (производные от класса \textpkg{book}) определено упомянутое
в начале раздела окружение \textenv{titlepage}, которое специально
предназначено для оформления титульного листа. Всё, что имеет
отношение к оформлению титульного листа, следует помещать внутри этого
окружения.

\mindex{титульный лист|)}
\subsection{Секционирование}
\label{sec:base:sec}

\mindex{оглавление}
\mindex{команды!секционирования|(}

Часто бывает полезно сразу за титульной страницей вывести оглавление с
помощью команды \textcmd{tableofcontents}, при этом не требуется
никаких дополнительных действий. Пример такого оглавления можно
увидеть в начале этой книги.

Оглавление создаётся автоматически только благодаря тому, что в тексте
присутствует логическое разбиение на разделы. Естественно, всё можно
сделать руками с помощью визуальной разметки, но тогда придётся забыть
об автоматизации, например, при создании того же оглавления.

Так начинается \emph{этот} раздел:
\begin{lstlisting}[]
\subsection{Секционирование}
\label{sec:base:sec}

Часто бывает полезно |\ldots|

\end{lstlisting}

Команды секционирования образуют строгую иерархию. Самыми старшими 
в~этой иерархии по <<званию>> 
являются разделы \textcmd{part}\lstinline!{Часть}! и
\textcmd{chapter}\lstinline!{Глава}!. Это очень большие куски текста и
соответственно их применение обосновано только в книгах, поэтому они
не определены в классах \textpkg{article}
(\textpkg{scrartcl}) и \textpkg{report}, зато определены в классе
\textpkg{book} (\textpkg{scrbook}).

Далее по старшинству следуют: 
\begin{lstlisting}[]
|\bs|section{Раздел}
\label{section}

|\bs|subsection{Подраздел}
\label{subsection}

|\bs|subsubsection[Подподраздел]{|Что-то более <<мелкое>>, чем подраздел|}
\label{subsubsection}

|\bs|paragraph{Параграф}
\label{paragraph}

|\bs|subparagraph{Подпараграф}
\label{subparagraph}

\end{lstlisting}

Если воспользоваться необязательным параметром команды
секционирования, то он замещает основной заголовок при печати
оглавления и создании колонтитулов.

Команды секционирования печатают заголовок необходимым шрифтом и
нумеруют раздел. Если нет желания, чтобы название раздела попало в
оглавление, и не нужна нумерация раздела, то к команде секционирования
следует добавить символ <<$*$>>, например,
\textcmd{section$*$}\lstinline!{Приложение}!.

\mindex{команды!секционирования|)}

\subsection{Перекрёстные ссылки}
\label{sec:base:ref}

\mindex{перекрёстные ссылки|(}

Одной из основных причин, по которой \LaTeX{} вытеснил обычный \TeX{}
из текстовых редакторов и умов \TeXников, является механизм нумерации и
создания ссылок.

Чтобы сослаться на раздел, в нём необходимо оставить метку
\textcmd{label}\lstinline!{метка}!. Метка представляет любую
комбинацию латинских букв, цифр и некоторых знаков препинания. В
частности при составлении меток удобно использовать двоеточие (:) и
тире (-). 

Сразу после определения заголовка этого раздела была поставлена
уникальная метка \textcmd{label}\lstinline!{sec:base:ref}!. Поэтому
теперь можно на этот раздел сослаться:
\begin{example}{base-ref-1}
Раздел <<Перекрёстные ссылки>> имеет
номер~\ref{sec:base:ref} и находится на
странице~\pageref{sec:base:ref}.
\end{example}

Когда ссылки идут через метку, то номер раздела (команда
\textcmd{ref}) и номер страницы (команда \textcmd{pageref})
определяется \LaTeX{} автоматически. Причём автоматическая нумерация
свойственна не только командам секционирования. Точно так же можно
ссылаться на формулы, таблицы, картинки, пункты перечня и листинги
программ. Для этого достаточно просто добавить метку \textcmd{label} после
команды именования соответствующего окружения. В случае таблиц или
картинок такой командой является \textcmd{caption}, а в случае пунктов
перечня "--- \textcmd{item}.

\mindex{перекрёстные ссылки|)}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../ctex"
%%% End: 
